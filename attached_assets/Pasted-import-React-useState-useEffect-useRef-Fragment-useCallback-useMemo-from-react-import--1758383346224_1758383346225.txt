import React, { useState, useEffect, useRef, Fragment, useCallback, useMemo } from 'react';
import {
  Sparkles, X, Loader2, Sun, Moon, Copy, FileText,
  Bold, Italic, Underline, AlignLeft, AlignCenter,
  AlignRight,
  Palette,
  Search, Replace, Save, FolderOpen, Printer, Eye, Settings,
  Download, Upload,
  FilePlus, Undo, Redo, Scissors,
  ChevronsRight, Pencil, ChevronDown,
  BookHeart, Film, MapPin, Camera, Feather, UserSquare,
  Parentheses, MessageCircle, FastForward, BrainCircuit, NotebookText
} from 'lucide-react';

// =============================================================================
// START: All necessary code is now included in this single file.
// =============================================================================

// Type Definitions for Agents and Context
interface AgentContext {
  lastCharacter?: string;
  inDialogue?: boolean;
  lastActionType?: string;
  currentScene?: string;
  lastLocation?: string;
  linePosition?: 'start' | 'middle' | 'end';
}

interface AgentResult {
  html: string;
  processed: boolean;
  confidence: number;
  elementType: string;
  agentUsed: string;
  originalLine: string;
  context: AgentContext;
}

type FormattingAgent = (line: string, ctx: AgentContext, getFormatStylesFn: (formatType: string) => React.CSSProperties) => AgentResult | null;

// Core Recognition Patterns
const Patterns = (() => {
  const c = (s: string | RegExp, flags = "") => new RegExp(s, flags);
  return {
    characterBullets: new RegExp("^([•○●◦▪▫■□◼◻⚫⚪🔴🔵⭕]+|[-–—*+])\\s*"),
    characterNames: new RegExp("^([\\u0600-\\u06FFا-ي\\s]+)\\s*[:：]\\s*"),
    sceneKeywords: c("^(مشهد|لقطة|منظر|مكان|زمن|وقت|SCENE|LOCATION|TIME)\\s*", "i"),
    locationWords: new RegExp("^(مسجد|بيت|منزل|دار|شقة|فيلا|مكتب|محل|دكان|مقهى|مطعم|فندق|مستشفى|مدرسة|جامعة|كلية|شارع|طريق|ميدان|حديقة|نيل|بحر|صحراء|جبل|قرية|مدينة|سيارة|أتوبيس|قطار|طائرة|باب|نافذة|سلم|سطح|بلكونة|حمام|مطبخ|صالة|غرفة)", "i"),
    timeIndicators: new RegExp("(ليل|نهار|صباح|ظهر|عصر|مغرب|عشاء|فجر|ضحى|صيف|شتاء|ربيع|خريف|أمس|اليوم|غدا|الآن|لاحقا|بعدها|قبلها|morning|night|day|evening)", "i"),
    actionKeywords: c("^(يدخل|يخرج|يقف|يجلس|يمشي|يجري|ينظر|يبتسم|يضحك|يبكي|يصرخ|يهمس|يفكر|يتذكر|فجأة|ببطء|بسرعة|بهدوء|بعنف)", "i"),
    directorNotes: c("^\\s*\\(.*\\)\\s*$"),
    transitions: c("^(قطع|قطع إلى|انتقال إلى|تلاشي|تلاشي أسود|CUT TO|FADE IN|FADE OUT|DISSOLVE TO)", "i"),
    numberedScene: c("^(مشهد|لقطة)\\s*(\\d+)\\s*[:：\\-–—]?\\s*(.*)", "i"),
    sceneHeader1: c(/^مشهد\s*\d+\s*$/i),
    sceneHeader2: {
      time: /(ليل|نهار|صباح|مساء)/i,
      inOut: /(داخلي|خارجي)/i,
    },
    sceneHeader3: c(/^(مسجد|بيت|منزل|شارع|حديقة|مدرسة|جامعة|مكتب|محل|مستشفى|مطعم|فندق|سيارة|غرفة|قاعة|ممر|سطح|ساحة|مقبرة|مخبز|مكتبة)/i),
  };
})();

const ActionType = {
  Movement: "movement", Observation: "observation", Speech: "speech",
  Emotion: "emotion", Temporal: "temporal", General: "general",
};

// getFormatStyles Function
const getFormatStyles = (formatType: string, selectedFont = 'Amiri', selectedSize = '12pt'): React.CSSProperties => {
    const baseStyles: React.CSSProperties = {
      fontFamily: `'${selectedFont}', monospace`,
      fontSize: selectedSize,
      direction: 'rtl',
      lineHeight: '1.5',
      minHeight: '1.2em'
    };
    
    const formatStyles: { [key: string]: React.CSSProperties } = {
      basmala: { textAlign: 'left', margin: '0' },
      'scene-header-top-line': { display: 'flex', justifyContent: 'space-between', width: '100%', margin: '1rem 0 0 0' },
      'scene-header-3': { textAlign: 'center', fontWeight: 'bold', margin: '0' },
      action: { textAlign: 'right', margin: '1rem 0' },
      character: { textAlign: 'center', fontWeight: 'bold', textTransform: 'uppercase', margin: '1rem auto 0 auto', width: '3.5in' },
      parenthetical: { textAlign: 'center', fontStyle: 'italic', margin: '0 auto', width: '3in' },
      dialogue: { textAlign: 'center', margin: '0 auto 1rem auto', width: '3.5in' },
      transition: { textAlign: 'center', fontWeight: 'bold', textTransform: 'uppercase', margin: '1rem 0' }
    };
    
    const finalStyles = { ...baseStyles, ...formatStyles[formatType] };
    
    if (formatType === 'scene-header-1') return { fontWeight: 'bold', textTransform: 'uppercase' };
    if (formatType === 'scene-header-2') return { fontStyle: 'italic' };
    
    return finalStyles;
};


function isValidCharacterName(name: string): boolean {
  if (!name) return false;
  if (name.length < 2 || name.length > 50) return false;
  if (/[^\u0600-\u06FFa-zA-Z\s]/.test(name)) return false;
  return !Patterns.actionKeywords.test(name);
}

function classifyAction(text: string): string {
  if (/يدخل|يخرج|يصل|يغادر/.test(text)) return ActionType.Movement;
  if (/ينظر|يراقب|يلاحظ/.test(text)) return ActionType.Observation;
  if (/يتكلم|يقول|يهمس|يصرخ/.test(text)) return ActionType.Speech;
  if (/يضحك|يبكي|يبتسم|يحزن/.test(text)) return ActionType.Emotion;
  if (/فجأة|بسرعة|ببطء/.test(text)) return ActionType.Temporal;
  return ActionType.General;
}

function compileHtml(tag: string, cls: string, text: string, getFormatStylesFn: (formatType: string) => React.CSSProperties, extra: React.CSSProperties = {}): string {
  const div = document.createElement(tag);
  div.className = cls;
  const baseStyles = getFormatStylesFn ? getFormatStylesFn(cls.split(' ')[0]) || {} : {};
  Object.assign(div.style, baseStyles, extra);
  div.textContent = text;
  return div.outerHTML;
}

// Formatting Agents
const SceneHeaderAgent: FormattingAgent = (line, ctx, getFormatStylesFn) => {
  const trimmedLine = line.trim();
  const m2 = trimmedLine.match(/^(مشهد\s*\d+)\s*[-–—:،]?\s*(.*)$/i);
  if (m2) {
    const head = m2[1].trim();
    const rest = m2[2].trim();
    if (rest && Patterns.sceneHeader2.time.test(rest) && Patterns.sceneHeader2.inOut.test(rest)) {
      const container = document.createElement('div');
      container.className = 'scene-header-top-line';
      const part1 = document.createElement('span');
      part1.className = 'scene-header-1';
      part1.textContent = head;
      const part2 = document.createElement('span');
      part2.className = 'scene-header-2';
      part2.textContent = rest;
      container.appendChild(part1);
      container.appendChild(part2);
      ctx.inDialogue = false;
      return { html: container.outerHTML, processed: true, confidence: 0.99, elementType: "scene-header-combined", agentUsed: "SceneHeaderAgent", originalLine: line, context: ctx };
    }
  }
  if (Patterns.sceneHeader3.test(trimmedLine)) {
    const html = compileHtml("div", "scene-header-3", trimmedLine, getFormatStylesFn);
    ctx.inDialogue = false;
    return { html, processed: true, confidence: 0.90, elementType: "scene-header-3", agentUsed: "SceneHeaderAgent", originalLine: line, context: ctx };
  }
  return null;
}

const CharacterDialogueAgent: FormattingAgent = (line, ctx, getFormatStylesFn) => {
    const direct = line.match(Patterns.characterNames);
    if (direct) {
        const name = direct[1].trim();
        const dialogue = line.substring(direct[0].length).trim();
        if (isValidCharacterName(name)) {
            const html = compileHtml("div", "character", name + " :", getFormatStylesFn) +
                         (dialogue ? compileHtml("div", "dialogue", dialogue, getFormatStylesFn) : "");
            ctx.lastCharacter = name;
            ctx.inDialogue = true;
            return { html, processed: true, confidence: 0.9, elementType: "character-dialogue", agentUsed: "CharacterDialogueAgent", originalLine: line, context: ctx };
        }
    }
    if (ctx.inDialogue) {
        return { html: compileHtml("div", "dialogue", line, getFormatStylesFn), processed: true, confidence: 0.8, elementType: "continued-dialogue", agentUsed: "CharacterDialogueAgent", originalLine: line, context: ctx };
    }
    return null;
}

const ActionAgent: FormattingAgent = (line, ctx, getFormatStylesFn) => {
    if (Patterns.actionKeywords.test(line)) {
        const html = compileHtml("div", `action`, line, getFormatStylesFn);
        ctx.inDialogue = false;
        return { html, processed: true, confidence: 0.85, elementType: `action`, agentUsed: "ActionAgent", originalLine: line, context: ctx };
    }
    return null;
}

const TransitionAgent: FormattingAgent = (line, ctx, getFormatStylesFn) => {
    if (Patterns.transitions.test(line)) {
        const html = compileHtml("div", `transition`, line, getFormatStylesFn);
        ctx.inDialogue = false;
        return { html, processed: true, confidence: 0.9, elementType: "transition", agentUsed: "TransitionAgent", originalLine: line, context: ctx };
    }
    return null;
}

const DirectorNotesAgent: FormattingAgent = (line, ctx, getFormatStylesFn) => {
  if (Patterns.directorNotes.test(line)) {
    const stripped = line.replace(/^\s*\(|\)\s*$/g, "").trim();
    const html = compileHtml("div", `parenthetical`, `(${stripped})`, getFormatStylesFn);
    return { html, processed: true, confidence: 0.85, elementType: "parenthetical", agentUsed: "DirectorNotesAgent", originalLine: line, context: ctx };
  }
  return null;
}

const DefaultAgent: FormattingAgent = (line, ctx, getFormatStylesFn) => {
  const html = compileHtml("div", "action", line, getFormatStylesFn);
  ctx.inDialogue = false;
  return { html, processed: true, confidence: 0.1, elementType: 'action', agentUsed: "DefaultAgent", originalLine: line, context: ctx };
}

// ScreenplayCoordinator Class
class ScreenplayCoordinator {
  getFormatStylesFn: (formatType: string, font?: string, size?: string) => React.CSSProperties;
  agents: FormattingAgent[];

  constructor(getFormatStylesFn: (formatType: string, font?: string, size?: string) => React.CSSProperties) {
    this.getFormatStylesFn = getFormatStylesFn;
    this.agents = [ TransitionAgent, DirectorNotesAgent, CharacterDialogueAgent, SceneHeaderAgent, ActionAgent, DefaultAgent ];
  }

  processLine(line: string, context: AgentContext = {}): AgentResult {
    for (const fn of this.agents) {
      const res = fn(line, context, this.getFormatStylesFn);
      if (res?.processed) return res;
    }
    return DefaultAgent(line, context, this.getFormatStylesFn) as AgentResult;
  }

  processScript(lines: string[]) {
    const ctx: AgentContext = {};
    const results = lines.map(ln => this.processLine(ln.trim(), ctx));
    return { results };
  }
}

// ============================================================================
// Main ScreenplayEditor Component
// ============================================================================
const ScreenplayEditor = () => {
  // State and Refs
  const editorRef = useRef<HTMLDivElement>(null);
  const scrollContainerRef = useRef<HTMLDivElement>(null);
  const [isDarkMode, setIsDarkMode] = useState(false);
  const [selectedFont, setSelectedFont] = useState('Amiri');
  const [selectedSize, setSelectedSize] = useState('12pt');
  const [pageCount, setPageCount] = useState(1);
  const [documentStats, setDocumentStats] = useState({ pages: 1, words: 0 });

  const coordinator = useMemo(() => new ScreenplayCoordinator((type, font, size) => getFormatStyles(type, font, size)), []);

  const updateStats = useCallback(() => {
    if (editorRef.current) {
      const text = editorRef.current.innerText || '';
      const words = text.trim().split(/\s+/).filter(Boolean).length;
      const pages = document.querySelectorAll('.page-background').length;
      setDocumentStats({ pages, words });
    }
  }, []);

  const handlePaste = useCallback((e: React.ClipboardEvent<HTMLDivElement>) => {
    e.preventDefault();
    const textData = e.clipboardData.getData('text/plain');
    if (!textData || !editorRef.current) return;
    
    const lines = textData.split('\n').filter(line => line.trim());
    const { results } = coordinator.processScript(lines);
    const formattedHTML = results.map(r => r.html).join('');
    
    // Clear editor and append new content
    editorRef.current.innerHTML = formattedHTML;

    // Re-apply styles after paste
    const divs = editorRef.current.querySelectorAll('div, span');
    divs.forEach(div => {
        const el = div as HTMLElement;
        if (el.className) {
            const baseClass = el.className.split(' ')[0];
            const styles = getFormatStyles(baseClass, selectedFont, selectedSize);
            Object.assign(el.style, styles);
        }
    });

    updateStats();
  }, [coordinator, selectedFont, selectedSize, updateStats]);

  useEffect(() => {
    updateStats();
  }, [pageCount, updateStats]);


  return (
    <div className={`flex flex-col h-screen transition-colors duration-300 ${isDarkMode ? 'bg-gray-800' : 'bg-gray-200'}`} dir="rtl">
      <link href="https://fonts.googleapis.com/css2?family=Amiri:wght@400;700&family=Courier+Prime&display=swap" rel="stylesheet" />

      <style dangerouslySetInnerHTML={{ __html: `
        .page-wrapper {
            padding: 1in 0;
            width: 100%;
            display: flex;
            justify-content: center;
        }
        .page-background {
          position: relative;
          width: 8.5in;
          min-height: 11in;
          background: ${isDarkMode ? '#2d3748' : '#ffffff'};
          box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .page-content {
          outline: none;
          direction: rtl;
          padding: 1in 1in 1in 1.5in;
          box-sizing: border-box;
          font-family: '${selectedFont}', monospace;
          font-size: ${selectedSize};
        }
      `}} />

      {/* Header */}
      <div className="flex-shrink-0 px-4 py-2 shadow-sm z-30 bg-gray-100 dark:bg-gray-700">
        <div className="flex justify-between items-center">
            <h1 className="text-lg font-bold" style={{fontFamily: 'Amiri'}}>محرر السيناريو</h1>
            <div className="flex items-center gap-2">
                 <select value={selectedFont} onChange={e => setSelectedFont(e.target.value)} className="p-1 border rounded bg-white dark:bg-gray-600">
                    <option value="Amiri">Amiri</option>
                    <option value="Courier Prime">Courier Prime</option>
                </select>
                <button onClick={() => setIsDarkMode(!isDarkMode)} className="p-2 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-600">
                    {isDarkMode ? <Sun size={18} /> : <Moon size={18} />}
                </button>
            </div>
        </div>
      </div>

      {/* Main Content */}
      <div className="flex-grow overflow-y-auto" ref={scrollContainerRef}>
        <div className="page-wrapper">
            <div className="page-background">
                <div 
                    ref={editorRef}
                    contentEditable={true}
                    suppressContentEditableWarning={true}
                    onPaste={handlePaste}
                    onInput={updateStats}
                    className="page-content"
                 />
            </div>
        </div>
      </div>

      {/* Footer */}
      <div className="flex-shrink-0 px-4 py-1.5 text-sm border-t bg-gray-100 dark:bg-gray-700">
        <span>{documentStats.pages} صفحة</span> | <span>{documentStats.words} كلمة</span>
      </div>
    </div>
  );
};

export default ScreenplayEditor;

